#!/usr/bin/env node

const os = require('os');
const path = require('path');
const fs = require('fs');
const https = require('https');
const { pipeline } = require('stream');
const { promisify } = require('util');
const pipelineAsync = promisify(pipeline);

function getPlatformPackageName() {
  const platform = os.platform();
  const arch = os.arch();
  
  let platformName, archName;
  
  if (platform === 'win32') platformName = 'win32';
  else if (platform === 'darwin') platformName = 'darwin';  
  else if (platform === 'linux') platformName = 'linux';
  else throw new Error(`Unsupported platform: ${platform}`);
  
  if (arch === 'x64') archName = 'x64';
  else if (arch === 'arm64') archName = 'arm64';
  else throw new Error(`Unsupported architecture: ${arch}`);
  
  return `@pulseengine/studio-mcp-server-${platformName}-${archName}`;
}

function checkPlatformPackage() {
  const packageName = getPlatformPackageName();
  
  try {
    const platformPackage = require(packageName);
    if (fs.existsSync(platformPackage.binaryPath)) {
      console.log(`âœ… Platform package ${packageName} installed successfully`);
      console.log(`   Binary available at: ${platformPackage.binaryPath}`);
      return true;
    }
  } catch (error) {
    // Platform package not available
  }
  
  return false;
}

async function fallbackDownload() {
  console.log('âš ï¸  Platform package not available, attempting fallback download...');
  
  const axios = require('axios');
  const tar = require('tar');
  const version = require('./package.json').version;
  const platform = os.platform();
  const arch = os.arch();
  
  let targetPlatform, targetArch;
  
  if (platform === 'win32') targetPlatform = 'pc-windows-msvc';
  else if (platform === 'darwin') targetPlatform = 'apple-darwin';
  else if (platform === 'linux') targetPlatform = 'unknown-linux-gnu';
  else throw new Error(`Unsupported platform: ${platform}`);
  
  if (arch === 'x64') targetArch = 'x86_64';
  else if (arch === 'arm64') targetArch = 'aarch64';
  else throw new Error(`Unsupported architecture: ${arch}`);
  
  const binaryName = platform === 'win32' ? 'studio-mcp-server.exe' : 'studio-mcp-server';
  const archiveExtension = platform === 'win32' ? 'zip' : 'tar.gz';
  const downloadUrl = `https://github.com/pulseengine/studio-mcp/releases/download/v${version}/studio-mcp-server-v${version}-${targetArch}-${targetPlatform}.${archiveExtension}`;
  
  console.log(`Downloading from: ${downloadUrl}`);
  
  try {
    const response = await axios({
      method: 'get',
      url: downloadUrl,
      responseType: 'stream'
    });
    
    const tempDir = path.join(__dirname, '.temp');
    const binDir = path.join(__dirname, 'bin');
    
    // Create directories
    if (!fs.existsSync(tempDir)) {
      fs.mkdirSync(tempDir, { recursive: true });
    }
    if (!fs.existsSync(binDir)) {
      fs.mkdirSync(binDir, { recursive: true });
    }
    
    const tempFile = path.join(tempDir, `download.${archiveExtension}`);
    const tempWriteStream = fs.createWriteStream(tempFile);
    
    await pipelineAsync(response.data, tempWriteStream);
    
    // Extract archive
    if (archiveExtension === 'tar.gz') {
      await tar.x({
        file: tempFile,
        cwd: binDir
      });
    } else {
      // Handle zip files (Windows)
      const yauzl = require('yauzl');
      await new Promise((resolve, reject) => {
        yauzl.open(tempFile, { lazyEntries: true }, (err, zipfile) => {
          if (err) return reject(err);
          
          zipfile.readEntry();
          zipfile.on('entry', (entry) => {
            if (/\/$/.test(entry.fileName)) {
              // Directory
              zipfile.readEntry();
            } else {
              // File
              const outputPath = path.join(binDir, path.basename(entry.fileName));
              zipfile.openReadStream(entry, (err, readStream) => {
                if (err) return reject(err);
                
                const writeStream = fs.createWriteStream(outputPath);
                readStream.pipe(writeStream);
                writeStream.on('close', () => zipfile.readEntry());
              });
            }
          });
          
          zipfile.on('end', resolve);
        });
      });
    }
    
    // Make binary executable
    const binaryPath = path.join(binDir, binaryName);
    if (fs.existsSync(binaryPath)) {
      fs.chmodSync(binaryPath, 0o755);
      console.log(`âœ… Binary downloaded and extracted to: ${binaryPath}`);
    } else {
      throw new Error(`Binary not found after extraction: ${binaryPath}`);
    }
    
    // Clean up temp files
    fs.rmSync(tempDir, { recursive: true, force: true });
    
  } catch (error) {
    console.error(`âŒ Fallback download failed: ${error.message}`);
    console.error('\nðŸ”§ Manual installation options:');
    console.error('1. Install from source: cargo install --git https://github.com/pulseengine/studio-mcp.git studio-mcp-server');
    console.error(`2. Download binary manually from: ${downloadUrl}`);
    throw error;
  }
}

async function main() {
  console.log(`Platform detected: ${os.platform()} ${os.arch()}`);
  
  // Check if platform package is available and working
  if (checkPlatformPackage()) {
    return; // All good!
  }
  
  // Try fallback download from GitHub releases
  try {
    await fallbackDownload();
  } catch (error) {
    process.exit(1);
  }
}

if (require.main === module) {
  main().catch(err => {
    console.error('Installation failed:', err.message);
    process.exit(1);
  });
}